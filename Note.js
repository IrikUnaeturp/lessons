Урок 1 Переменные
Для создания коробки(переменной)в которой будет хранится записка(значение) пишем: let number=10
Для создания имени переменной есть всего 2 правила: 1. имя может содержать буквы, цифры или сиволы "$","_"
                                                    2.  цифра не может стоять первой
Переменные с именами APPLE и apple -это разные переменные  
Существует список имён, которые нельзя использовать в качесте имени переменной: let, 
class, return и function
Можно создатьпеременную просто присвоив ей значениебез слова "let", если мы НЕ напишем перед этим 
команду в кавычках"use strict", в противном случае выдаст  ошибку  сообщающую нам о  том что переменная 
не найдена

Константы
в отличие от переменных константам не возможно поменять присвоенное значение
в место let пишем const
Если мы с самого начала знаем значание константы,  то имя пишем заглавными буквами, если значение 
константы узнаётся в середине кода, тогда пишем имя маленькими буквами

Необходимо научится задавать правельные  и  понятные имена, что бы было понятно сразу , что в себе 
содержит переменная 
Лучше создать больше переменных, чем использовать одну для всего, она  как коробка наполненная хаусом и 
нужно подойти и посмотреть, что б понять что в ней

Урок 2 Типы данных
Значения в JavaScript всегда относяться к какому-то типу данных, например к строке или числу
Кроме обычных чисел ещё существуют "специальные числовые значения", которые относятся к такому 
типу данных: Infinity, -Infinity, NaN
Infiniti (то есть бесконечноть  можно  получить в результате деления на  ноль)
NaN(означает вычислительную ошибку) его можно использоввать как математический термен, если хоть где-то 
в математических выражениях есть NaN, то и результатом будет NaN,  исключение  только NaN**0=1

BigInt
В JavaScript тип number не может безопасно работать с  чилами больше  чем 2^53-1 и меньше чем-(2^53-1)
В основном этогодиапазона для  работы достаточно, но есть случаи когда нам нужно работать с числами больше
 этого диапазона, тогда мы используем тип BigInt
Чтобы создать тип BigInt, добавляем букву  n после значения: let bigInt=87359667584576736457n

Строка(string)
Строка должна быть обязательно в кавычках, естьвсего 3 типа ковычек: '',"", и ``.
между  1 и 2 разницы нет, а вот 3 `перевёрнутые ковычки` имеют дополнительную функцию,а именно встраивать
 выражения в строку с помощью ${...}
Например: let name='Иван';console.log( `Привет, ${name}!`)\\выйдет Привет, Иван!
          ( `результат: ${1 + 2}` )\\результат: 3

Булевый тип
Может приниматьтолько 2 значения true или false. Этот тип как правило используется для хранения значений 
да/нет или как результат сравнений

Значение 'null'
Это специальное значение для пустоты, ничего

Значение 'undefinded'
Это означает, что не было присвоенно значение, и из-за этого не было найдено в коде

Объекты и символы
Тип object. В объектах хранятся колекции данных и более сложные структуры, чем в примитивных типах данных,
которые хранят в себе только строки и числа
А тип symbol используется для создания  уникальных идентификаторов в объектах

Оператор typeof
Этот  оператор возвращает  тип аргумента, к примеру typeof 0 // "number", typeof true // "boolean"
let people  = "pidr";
if (typeof (people) === 'number'){
    console.log(true)
}
else{
    console.log(false)
}

Урок 3
Преобразование  типов
Есть 3 типа: строковаое, численое и логическое
строковое преобразование - происходит когда требуется представление чего-либо ввиде строки, например 
console.log(value), так же мы можем использовать String(value)
let value = true
console.log(typeof value)//boolean

value = string(value)
console.log(typeof value)//string

Численое преобразование - происходит в математических функциях и выражениях, например когда операция
 деления (/) применяется не к числу console.log("6" / "2")//3, строки преобразуются в числа
Мы можем испозьзовать Number(value), чтобы явно преобразить  value к числу. Если с помощью   Number  
преобразовать True будет равен  1, а False=0,null=0
let str = "123"
console.log(typeof str)//string

let num = Number(str)// str долженбыть равен только числам, если будут буквы то выдаст NaN
console.log(typeof num)// number

Логическое преобразование -  выполнено с помощью функции boolean, пустые значения (0,  пустая  строка, 
    null, undefinded, NaN)=  False все остальные  =True
console.log(Boolean(1))//true
console.log(Boolean(0))//false

console.log(Boolean"Privet!")//true
console.log(Boolean"")//false

Урок 4
Базовые операторы,математика
Базовые операторы +-*/
Термены "унарный" "бинарный" "операнд". Операнд - это то к чему применяется оператор 5*2 левый операнд 
равен 5  и правый операнд равен 2
Унарным назвается оператор, который применяется к одному операдну
let x=1
x=-x
console.log(x)//-1

Бинарным называется оператор который применяется к двум операндам
let  x=1, y=3
console.log(y-x)//2

Поддерживаются следуйщие математические значения:  +-*/ %(взятие остатка деления)  ** (возыедение в степень) 
x** 1/2 (квадратный корень из х)
С помощью +  можно объеденить строки, и если хоть один операнд является строкой, то второй  так же 
превратится в строку, например console.log(1+'2');//12
Сложение и преобразование строк - это особенностьбинарного плюса, другие. Другие арифметические операторы 
работают только с числами и всегда  преобразуют операнды  в  числа console.log(6-"2");//4 
Плюс есть бинарный и унарный, выше я использовала бинарный. Унарный, то есть используется только к одному
 операнду, числа он никак не меняет, но если операнд не число,то унарный плюс его преобразит в число 
 console.log(+true);//1; console.log(+"");//0
let apples = "2"; let oranges="3"; console.log(+apples+ +oranges);//5, если написать просто apples+oranges, 
то сложаться строки и выдаст 23

Приоритеты операторов: 1. унарный  плюс и унарный минус, 2.возведение в степень, 3.умножение,деление, 
4.сложение, вычитание, 5.присваивание
Есть сокращённая арифметика с присваиванием, что бы не писать let n=10; n=n*2;, лучше  будет сократить и 
написать let n=10; n*=2; Подобные краткие формы записи существуют для всех арифметических и побитовых 
операторов

Одной из более частых числовых операций является увеличение или уменьшенее на 1, для этого существуют даже 
отдельные  операторы Инкремент++ и Декремент--
Инкремент и Декремент можно использовать только к переменной, ++5 выдаст ошибку, let counter=2; ++counter;
 console.log(counter);//3 еще ++ перед переменной означает что +1  будет в следйщем вызове, а ++ после
  сразу выдаст +1
Побитовые операторы: AND - и(&); OR - или (|); XOR - побитовое исключающее или(^); NOT - не (~); LEFT SHIFT - 
левый сдвиг(<<);RIGHT SHIFT - правый сдвиг (>>);ZERO-FILL RIGHTSHIFT- правый сдвиг с заполнениями нуля(>>>)
Оператор запятая: Используем запятую для разделения выражений, при этом будет выполнятся только последнее 
let a=(1+2,3+4);/7

Урок 5 Операторы сравнения
Как и в математике для сравзнения есть знаки больше(>) меньше(<) и равно(==), для сравнения используются 
именно 2 знака равно,один знак равно означает присваивание, для знака меньше/больше или равноиспользуем 
сочетание >=,<= и не равно !=. Все операторы после сравнения возращают или true или false. 
Так же можно сравнивать между собой не только  числа, но и строки,для этого JavaScript использует
алфавитный порядок Я>A//true, но строчные буквы не равны заглавным, JavaScript  считает что заглавная 
буква меньше чем строчная, поэтому А<а = true
Сравнение разных типов, при  сравнение разных типов JS  приводит каждое из них к  числу, '2'==2//true, 
само значение true=1,a false=0
Строгое сравнение. == - можетвызвать проблемы,ведь он не видит разници между 0,false и '', тогда используем
 ===, оно сравнивает без преобразование в один тип, так же есть оператор строгого неравенства !==
Сравнение с null и undefined. При использовании математических тепренов значения null/undefined 
преобразуются к  числам, null становится 0, а undefined - NaN

Урок 6 Условноеветвление if, '?'
Инструкция if(...) вычисляет условие  в скобкахи если результат true то выполняет код. 
If(...){console.log(...);}
Число 0, пуста строка '' , Null, undefined  и  NaN становятся False
Остальные значения становаятся True
Инструкция может содержать необязательный блок else(иначе), он выпоняется когда условие ложно. 
Иногда нужно проверить несколько  вариантов, для этого  используется блок else if
Оператор  "?"
let result  = условие  ? значение1 : значение2; Сначала вычисляется условие,если оно  
правдиво возвращается значени1,  если нет то значение2
 Иногда оператор "? " используется вместо If

 Урок 7 Логические операторы
 ||(или) &&(и) !(не) ??(оператор нулевого слияния)
 || - возвращает true если хоть один из аргументов true, true||true=true; 
 false||true=true;false||false=false - это традиционная логика
 так же есть расширенный алгоритм использования  оператора 'или', например result = value1||value2||value3;  
 выпоняются следуйщие действия 1. Вычисляются операнды слева направо 2. Каждый операнд конвертирует 
 логическое значение. Если результат true, возвращает исходное значение этого операнда 
 3. Если все операнды ложные, то  возвращает последний из них
 (1||0); 1;   (true||'no matter what');true; (null||1);1; (null||0||1);1   (undefined||null||0);0

&&- 'и' возвращает true только если оба  операнда true, иначе false
result=value1&&value2&&value3;1.слева направо 2.Если результат false останавливается и выводит 
исходное значение этогооперанда 3.  Если все true то выводит последнее истенное значение
приоритет оператора && больше чем ||   как если бы выпонялось (a&&b)||(c&&d), а оператор "не" 
имеет более высщую категорию и будет выполнятся первее "и"  или "или"

!-оператор 'не' result=!value; 1.приводит к логическому аргументу true/false 
2. меняет на противоположенное 
!!- двойной оператор "не" используют для преобразования к логическому типу

урок 8
Оператор нулевого слияния (??)
Он обрабатывает  null и  undefinded одинаковым образом
a ?? b = результат будет: если а оперделенно, то a, если нет, то b
resul=a??b  тоже самое что и result=(a!==null &&a!==undefined)? a:b
оператор "или" || может быть использован для того же что и ??, отличие между ними только
 в том что ||-возвращает первое истиное значение,а ??-возвращает первое определенное значение
приоритет ??  такой же как и || равен 3 в таблице на MND, это означает что ?? выполняется после = и ? 
но до таких операций как +*/
чтобы использовать в одном выражении и ?? и && или ||  то нужно использовать скобки иначе выдаст 
ошибку let x=(1&&2)??3;

урок 9
Циклы while и for
while(condition){
    //код
    //так же называемый: телом цикла
}
код из тела цикла выполняется пока condition is true 

Любое выражение или переменная может быть условием цикла,  например  while (i) тоже что и while (i!=0)

цикл do...while
do{
    //тело цикла
} while(condition);     
цикл сначало выполнит тело а затем проверит условие condition и пока его значение равно true 
он будет выполнятся снова и снова 

цикл for
for(начало; условие;шаг){
    //тело  цикла
}

Прерывание цикла break
обычно цикл заканчивается, когда условие равняется false, но мы может прервать  цикл раньше с помощью 
директивы break if(x===0)break;

Переход к следуйщей итерации: continue
Директива continue облегчённая версия break,при её выполнении цикл не прерывается а переходит к следуйщей 
итерации

урок 10
Конструкция switch заменяет собой сразу несколько if, она представляет собой наглядный пример 
сравнивать  выражения сразу с несколькими вариантами. Конструкция switch имеет один или более блок case
и необязательный блок default.

switch(x){
    case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
.переменная x проверяется на строгое равенство сначала со значением value1  потом с value2 и т.д
.Если соответствие установленно -  switch  начинает начинает выполнятся от соответствующей директивы
 case  и далее до ближайшего break(или до конца switch)
.Если ни один case не совпал,  то выполняется,  если есть, вариант default

Групировка case : можно  групировать несколько вариантов case 
case 3: // (*) группируем оба case
case 5:
    console.log('Неправильно!');
    console.log("Может вам посетить урок математики?");
    break; //3  и  5 теперь выводят одно и тоже  сообщение

Тип имеет значение!!
Проверка на равенствовсегда строгая и значения должны быть одного типа, что бы выполнялось равенство

let arg = prompt("Введите число?");
switch (arg) {
  case '0':
  case '1':
    console.log( 'Один или ноль' );
    break;

  case '2':
    console.log( 'Два' );
    break;

  case 3:
    console.log( 'Никогда не выполнится!' );
    break;
  default:
    console.log( 'Неизвестное значение' );
}

Для '0' и '1' выполнится первый console.log.
Для '2' – второй console.log.
Но для 3, результат выполнения prompt будет строка "3", которая не соответствует строгому равенству ===
с числом 3. Таким образом, мы имеем «мёртвый код» в case 3! Выполнится вариант default.

Урок 11
функции
функции созданы для того чтобы не вызывать по несколько раз один и тот же код во многих местах. Функция -
это "основные строительные" блоки программы, например console.log() это функция

Объявление функции
для создания функции мы можем использовать объявление функции, выглядит это так:
function showMessage() {
    console.log( 'Всем привет!' );
  }
Наша новая функция может быть вызвана с помощью своего имени showMessage()
function showMessage() {
    console.log( 'Всем привет!' );
  }
  
  showMessage();
  showMessage();
Здесь мы увидим сообщение дважды

Локальные переменные
Переменные объявленные внутри  функции видны только внутри этой функции
function showMessage() {
    let message = "Привет, я JavaScript!"; // локальная переменная
  
    console.log( message );
  }
  
  showMessage(); // Привет, я JavaScript!
  
  console.log( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции

Внещние переменные
У функции есть доступ к внешним переменным
let userName = 'Вася';

function showMessage() {
  let message = 'Привет, ' + userName;
  console.log(message);
}

showMessage(); // Привет, Вася

Функция обладает полным доступом к  внешним переменным и  может изменять их значение
let userName = 'Вася';

function showMessage() {
  userName = "Петя"; // (1) изменяем значение внешней переменной

  let message = 'Привет, ' + userName;
  console.log(message);
}

console.log( userName ); // Вася перед вызовом функции

showMessage();

console.log( userName ); // Петя, значение внешней переменной было изменено функцией

Внешняя переменная используется только если нет локальной
А если будет однаимённая внешняя переменная и внутренняя,  внутрення перекроет внешнюю
let userName = 'Вася';

function showMessage() {
  let userName = "Петя"; // объявляем локальную переменную

  let message = 'Привет, ' + userName; // Петя
  console.log(message);
}

// функция создаст и будет использовать свою собственную локальную переменную userName
showMessage();

console.log( userName ); // Вася, не изменилась, функция не трогала внешнюю переменную


Параметры
с помощью параметров мы можем передать внутрь функции любую информацию
ниже я использую параметри from и Text

function showMessage(from, text) { // параметры: from, text
    console.log(from + ': ' + text);
  }
  
  showMessage('Аня', 'Привет!'); // Аня: Привет! (*)
  showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)

Когда функция вызывается в строках (*) и (**), переданные значения копируются в локальные переменные from 
и text. Затем они используются в теле функции.

Вот ещё один пример: у нас есть переменная from, и мы передаём её функции. Обратите внимание: 
функция изменяет значение from, но это изменение не видно снаружи. Функция всегда получает только копию 
значения:
function showMessage(from, text) {

    from = '*' + from + '*'; // немного украсим "from"
  
    console.log( from + ': ' + text );
  }
  
  let from = "Аня";
  
  showMessage(from, "Привет"); // *Аня*: Привет
  
  // значение "from" осталось прежним, функция изменила значение локальной переменной
  console.log( from ); // Аня

Параметр – это переменная, указанная в круглых скобках в объявлении функции.
Аргумент – это значение, которое передаётся функции при её вызове.

Рассматривая приведённый выше пример, мы могли бы сказать: 
"функция showMessage объявляется с двумя параметрами, затем вызывается с двумя аргументами: 
from и "Привет""

Значения по умолчанию
Если при вызову функции аргумент не был указан, то его значением становится undefined
Например, вышеупомянутая функция showMessage(from, text) может быть вызвана с одним аргументом:

showMessage("Аня");
Это не приведёт к ошибке. Такой вызов выведет "*Аня*: undefined". В вызове не указан параметр text, 
поэтому предполагается, что text === undefined.

Если мы хотим задать параметру text значение по умолчанию, мы должны указать его после =:

function showMessage(from, text = "текст не добавлен") {
  console.log( from + ": " + text );
}

showMessage("Аня"); // Аня: текст не добавлен
Теперь, если параметр text не указан, его значением будет "текст не добавлен"


в случае, если большинство ложных значений, таких как 0, следует расценивать как «нормальные».

function showCount(count) {
    // если count равен undefined или null, показать "неизвестно"
    console.log(count ?? "неизвестно");
  }
  showCount(0); // 0
  showCount(null); // неизвестно
  showCount(); // неизвестно

Возврат значения
function sum(a, b) {
    return a + b;
  }
  
  let result = sum(1, 2);
  console.log( result ); // 3

Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого 
места, функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной 
result выше).

Вызовов return может быть несколько, например:
function checkAge(age) {
    if (age >= 18) {
      return true;
    } else {
      return confirm('А родители разрешили?');
    }
  }
  
  let age = prompt('Сколько вам лет?', 18);
  
  if ( checkAge(age) ) {
    console.log( 'Доступ получен' );
  } else {
    console.log( 'Доступ закрыт' );
  }


Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке,
что и return. Или, хотя бы, поставить там открывающую скобку, вот так:

return (
 some + long + expression
 + or +
 whatever * f(a) + f(b)
  ) 


Выбор имени функции
Функция – это действие. Поэтому имя функции обычно является глаголом. 
Оно должно быть кратким, точным и описывать действие функции

Функции, начинающиеся с…

"get…" – возвращают значение,
"calc…" – что-то вычисляют,
"create…" – что-то создают,
"check…" – что-то проверяют и возвращают логическое значение, и т.д.
showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (получая его каким-то образом)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false

Функции==Коментарии
Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл 
разбить функцию на несколько меньших. Иногда следовать этому правилу непросто, но это определённо 
хорошее правило.

Урок 12
Function  Expression
Существует ещё один синтаксис создания функций, который называется Function Expression (Функциональное Выражение).

Данный синтаксис позволяет нам создавать новую функцию в середине любого выражения.

Это выглядит следующим образом:

let sayHi = function() {
  console.log( "Привет" );
};
Поскольку создание функции происходит в контексте выражения присваивания (с правой стороны от =),
 это Function Expression.

Обратите внимание, что после ключевого слова function нет имени. Для Function Expression допускается 
его отсутствие.

Здесь мы сразу присваиваем её переменной, так что смысл этих примеров кода один и тот же: 
"создать функцию и поместить её в переменную sayHi".


Мы можем скопировать функцию в другую переменную:

function sayHi() {   // (1) создаём
  console.log( "Привет" );
}

let func = sayHi;    // (2) копируем

func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет    //     эта тоже все ещё работает (почему бы и нет)
Давайте подробно разберём всё, что тут произошло:

Объявление Function Declaration (1) создаёт функцию и помещает её в переменную с именем sayHi.
В строке (2) мы скопировали её значение в переменную func. Обратите внимание (ещё раз): нет круглых скобок 
после sayHi. Если бы они были, то выражение func = sayHi() записало бы результат вызова sayHi() 
в переменную func, а не саму функцию sayHi.
Теперь функция может вызываться как sayHi(), так и func().

Урок 13
Стрелочные функции
Существует ещё один очень простой и лаконичный синтаксис для создания функций, который часто лучше, 
чем Function Expression.

let func = (arg1, arg2, ...argN) => expression;

Давайте рассмотрим конкретный пример:

let sum = (a, b) => a + b;

/* Эта стрелочная функция представляет собой более короткую форму:

let sum = function(a, b) {
  return a + b;
};
*/

console.log( sum(1, 2) ); // 3

Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить, сделав запись ещё короче:

let double = n => n * 2;
// примерно тоже что и: let double = function(n) { return n * 2 }

console.log( double(3) ); // 6

Если аргументов нет, круглые скобки будут пустыми, но они должны присутствовать:

let sayHi = () => console.log("Hello!");

sayHi();


Иногда нам нужна более сложная функция, с несколькими выражениями и инструкциями.Это также возможно, нужно лишь заключить их в фигурные скобки. При этом важное отличие – в том, что в таких скобках для возврата значения нужно использовать return (как в обычных функциях).

Вроде этого:

let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};

console.log( sum(1, 2) ); // 3

Урок 14
Основы JavaScript 
Чтобы по максимуму использовать возможности современного JavaScript, все скрипты рекомендуется начинать 
с добавления директивы "use strict".

'use strict';

...
Эту директиву следует размещать в первой строке скрипта или в начале тела функции.

Без "use strict" код также запустится, но некоторые возможности будут работать в «режиме совместимости» 
со старыми версиями языка JavaScript.

Урок 15
Качествро кода
1. Фигурные скобки
if (n < 0) {
  console.log(`Степень ${n} не поддерживается`);
}
Для очень короткого кода допустима одна строка. Например: if (cond) return null. Но блок кода 
(последний вариант) обычно всё равно читается лучше.

2.Отступы
  Горизонатльные отступы 2 4 пробела. Например, мы можем выровнять аргументы относительно открывающей
  скобки:

  show(parameters,
       aligned, // 5 пробелов слева
       one,
       after,
       another
    ) {
    // ...
  }
  Вертикальные отступы
  Даже одну функцию часто можно разделить на логические блоки. В примере ниже разделены инициализация 
  переменных, основной цикл и возвращаемый результат:

function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
Вставляйте дополнительный перевод строки туда, где это сделает код более читаемым. Не должно быть
более 9 строк кода подряд без вертикального отступа.

3. Уровень вложенности 
Например, вместо добавления вложенного условия if, как здесь:

for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- ещё один уровень вложенности
  }
}
Мы можем написать:

for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- нет лишнего уровня вложенности
}



Урок 16
Коментарии

комментарии могут быть однострочными, начинающимися с //, и многострочными: /* ... */.

В хорошем коде должно быть мало коментариев `Если код настолько запутанный, что требует комментариев, 
то, может быть, его стоит переделать?`

Комментируйте:

Общую архитектуру, вид «с высоты птичьего полёта».
Использование функций.
Неочевидные решения, важные детали.

Избегайте комментариев:

Которые объясняют, как работает код, и что он делает.
Используйте их только в тех случаях, когда невозможно сделать настолько простой и 
самодокументированный код, что он не потребует комментариев.

Урок 17
Ниндзя-код. 

Не пиши "как короче", а пиши как понятней
// код из jQuery
i = i ? i < 0 ? Math.max(0, len + i) : i : 0; - так не надо 

не использовать коротныкие имена переменных, типа a,b,c. Но есть одно исключение. В тех местах, 
где однобуквенные переменные общеприняты, например, в счётчике цикла – используйте стандартные
названия i, j, k.

Не  используйте сокращения.list → lst. userAgent → ua. browser → brsr. - так не надо

При выборе имени НЕ применяйте абстрактное слово, например obj, data, value, item, elem и т.п.

Не используйте похожие  имена переменных как date и data

Не используйте русские слова как let ssilka

Не  используйте разные названия для одинаковых обозначений например если метод показывает что-то на 
экране – начните его название с display.. (скажем, displayElement), в другом месте уже НЕ объявляйте
аналогичный метод как show.. (showFrame).

И напротив, если есть две функции с важными отличиями – не используйте одно и то же слово для их описания!
Например, с print... можно начать метод печати на принтере printPage, а также – метод добавления текста 
на страницу printText.

Не используйте повторно одно имя для нескольких переменных

Не добавляйте лишние подчеркивания это только удлиняет код и уменьшает читаемость, например _name; value_;

Имена superElement, megaFrame и niceItem не несёт никакой конкретики. Читающий может решить поискать 
в этом глубинный смысл и замедитировать на часок-другой оплаченного рабочего времени.

Плохо еще использовать  одни и теже названия переменных и в функции и за пределами

Есть функции, название которых говорит о том, что они ничего не меняют. Например, isReady(), 
checkPermission(), findTags()… Предполагается, что при вызове они произведут некие вычисления или найдут
и возвратят полезные данные, но при этом их не изменят. В трактатах это называется
«отсутствие сторонних эффектов». В таких функциях не нужно делать ничего "полезного"

Ограничивайте действия функции тем, что написано в её названии. Например, функция validateEmail(email)
должна проверять email только на правильность, а вывести сообщение об ошибке и просьбой ввести заного
пусть занимктся другая функция  с подходящим названием

Урок 18
Полифилы           ьт                                        
Когда мы используем современные возможности JavaScript, некоторые движки могут не поддерживать их.
И тут приходит на помощь Babel.

Babel – это транспилер. Он переписывает современный JavaScript-код в предыдущий стандарт.
Термин «полифил» означает, что скрипт «заполняет» пробелы и добавляет современные функции.

Два интересных хранилища полифилов:

core js поддерживает много функций, можно подключать только нужные.
polyfill.io – сервис, который автоматически создаёт скрипт с полифилом в зависимости от 
необходимых функций и браузера пользователя.

Таким образом, чтобы современные функции поддерживались в старых движках, нам надо установить транспилер 
и добавить полифил.

Большинство примеров можно запустить «на месте», как этот:

console.log('Нажмите кнопку "Play" в крайнем правом углу, чтобы запустить пример');
Примеры, в которых используются современные возможности JS, будут работать, если ваш браузер их 
поддерживает.

Урок 19
Объекты
Используются для хранения коллекций различных значений   

Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. Свойство – 
это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может
быть чем угодно.

Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:

let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"

При использованиии литерального синтаксиса { } мы можем поместить сразу несколько своиств в виде пар: `ключ
: значение`

let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};

Можно сказать, что наш объект user – это ящик с двумя папками, подписанными «name» и «age».
Мы можем в любой момент прочесть содержимое папки или удалить его с помощью:
// получаем свойства объекта:
console.log( user.name ); // John
console.log( user.age ); // 30

delete user.age;// для удаления

Значение может быть любого типа. Давайте добавим свойство с логическим значением:
user.isAdmin = true;

Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:

let user = {
  name: "John",
  age: 30,
  "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};



Последнее свойство объекта может заканчиваться запятой:

let user = {
  name: "John",
  age: 30,
}
Это называется «висячая запятая». Такой подход упрощает добавление, удаление и перемещение свойств,
так как все строки объекта становятся одинаковыми.


Объект, объявленный через const, может быть изменён.

Например:

const user = {
  name: "John"
};

user.name = "Pete"; // (*)

console.log(user.name); // Pete
Может показаться, что строка (*) должна вызвать ошибку, но нет, здесь всё в порядке. Дело в том, 
что объявление const защищает от изменений только саму переменную user, а не её содержимое.

Определение const выдаст ошибку только если мы присвоим переменной другое значение: user=....

Для своиств содержащих несколько слов доступ к значению  "через точку" не работает 
// это вызовет синтаксическую ошибку
user.likes birds = true

Точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов, 
не начинался с цифры и не содержал специальные символы, кроме $ и _. В таком  случае мы используем
квадратные  скобки

// присваивание значения свойству
user["likes birds"] = true;

// получение значения свойства
console.log(user["likes birds"]); // true

// удаление свойства
delete user["likes birds"];


Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. 
Например, имя свойства может храниться в переменной:

let key = "likes birds";

// то же самое, что и user["likes birds"] = true;
user[key] = true;

Переменная key может зависеть отпользовательского кода, пример:

let user = {
  name: "John",
  age: 30
};

let key = prompt("Что вы хотите узнать о пользователе?", "name");

// доступ к свойству через переменную
console.log( user[key] ); // John (если ввели "name")
Запись «через точку» такого не позволяет:

let user = {
  name: "John",
  age: 30
};

let key = "name";
console.log( user.key ); // undefined

Своиство из переменной
В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств 
с тем же именем.

Например:

function makeUser(name, age) {
  return {
    name: name,
    age: age
    // ...другие свойства
  };
}

let user = makeUser("John", 30);
console.log(user.name); // John

Вместо name:name мы можем написать просто name:

Ограничения на имена своиств 
Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, 
такими как «for», «let», «return» и т.д.

Но для свойств объекта такого ограничения нет:

// эти имена свойств допустимы
let obj = {
  for: 1,
  let: 2,
  return: 3
};

console.log( obj.for + obj.let + obj.return );  // 6
Иными словами, нет никаких ограничений к именам свойств(Кроме свойства __proto__ ). Они могут быть 
в виде строк или символов

Проверка существования своиства, оператор in 
В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к 
любому свойству. Даже если свойства не существует – ошибки не будет!

let user = {};

console.log( user.noSuchProperty === undefined ); // true означает "свойства нет"
Также существует специальный оператор "in" для проверки существования свойства в объекте.

Синтаксис оператора:

"key" in object

Пример:

let user = { name: "John", age: 30 };

console.log( "age" in user ); // true, user.age существует
console.log( "blabla" in user ); // false, user.blabla не существует

Цикл for...in
Синтаксис:

for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

Упорядочение своиств объекта
Короткий ответ: свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по 
возрастанию, остальные располагаются в порядке создания. Разберёмся подробнее.

В качестве примера рассмотрим объект с телефонными кодами:

let codes = {
  "49": "Германия",
  "41": "Швейцария",
  "44": "Великобритания",
  // ..,
  "1": "США"
};

for (let code in codes) {
  console.log(code); // 1, 41, 44, 49
}
Если мы делаем сайт для немецкой аудитории, то, вероятно, мы хотим, чтобы код 49 был первым.

Но если мы запустим код, мы увидим совершенно другую картину:

США (1) идёт первым
затем Швейцария (41) и так далее.
Телефонные коды идут в порядке возрастания, потому что они являются целыми числами: 1, 41, 44, 49.

// Math.trunc - встроенная функция, которая удаляет десятичную часть
console.log( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
console.log( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
console.log( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное

Добавления знака "+" перед каждым кодом будет достаточно.

Пример:

let codes = {
  "+49": "Германия",
  "+41": "Швейцария",
  "+44": "Великобритания",
  // ..,
  "+1": "США"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
Теперь код работает так, как мы задумывали.


Урок 20
Копирование объектов и их ссылки
При копировании переменной объекта копируется ссылка, но сам объект не дублируется.

Например:

let user = { name: "John" };

let admin = user; // копируется ссылка
Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект:

Мы можем использовать любую переменную для доступа к объекту и изменения его содержимого:

let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // изменено по ссылке из переменной "admin"

alert(user.name); // 'Pete', изменения видны по ссылке из переменной "user"
Это как если бы у нас был шкафчик с двумя ключами, и мы использовали один из них (admin), чтобы войти
в него и внести изменения. А затем, если мы позже используем другой ключ (user), мы все равно открываем 
тот же шкафчик и можем получить доступ к изменённому содержимому.

Сравнение по ссылке
Два объекта равны только в том случае, если это один и тот же объект.

Например, здесь a и b ссылаются на один и тот же объект, поэтому они равны:

let a = {};
let b = a; // копирование по ссылке

alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true
И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):

let a = {};
let b = {}; // два независимых объекта

alert( a == b ); // false

Клонирование и объединение, Object.assign

Итак, копирование объектной переменной создаёт ещё одну ссылку на тот же объект.

Но что, если нам всё же нужно дублировать объект? Создать независимую копию, клон?

Это тоже выполнимо, но немного сложнее, потому что в JavaScript для этого нет встроенного метода. 
Но на самом деле в этом редко возникает необходимость, копирования по ссылке в большинстве случаев вполне 
хватает.

Но если мы действительно этого хотим, то нам нужно создать новый объект и воспроизвести структуру 
существующего, перебрав его свойства и скопировав их на примитивном уровне.

Например так:

let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект

// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

alert( user.name ); // все ещё John в первоначальном объекте
Также мы можем использовать для этого метод Object.assign.

Синтаксис:

Object.assign(dest, [src1, src2, src3...])
Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, 
свойства всех аргументов, начиная со второго, копируются в первый объект.
Возвращает объект dest.
Например, мы можем использовать его для объединения нескольких объектов в один:

let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "John", canView: true, canEdit: true }